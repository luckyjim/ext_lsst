# Copyright (C) 2012-2020 Euclid Developers
#
# This file is part of MerDataModelUtils.
#
# MerDataModelUtils is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation, either version 3 of
# the License, or (at your option) any later version.
#
# MerDataModelUtils is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this library.  If not, see <http://www.gnu.org/licenses/>

"""Some utility methods to work with the Euclid Common Data Model.

Created on: 24/11/16
Author: Javier Gracia Carpio (jgracia@mpe.mpg.de)
"""
from builtins import str
import logging
import pyxb
import os
from datetime import datetime

import ST_DataModelBindings.bas.cat_stub as catDict
import ST_DataModelBindings.bas.cot_stub as cotDict
import ST_DataModelBindings.bas.imp.raw.stc_stub as stcDict
import ST_DataModelBindings.bas.raw.dtd_stub as dtdDict
import ST_DataModelBindings.bas.imp.eso_stub as esoDict
import ST_DataModelBindings.bas.msk_stub as mskDict
import ST_DataModelBindings.bas.ppr_stub as pprDict
import ST_DataModelBindings.ins_stub as insDict
import ST_DataModelBindings.bas.img_stub as imgDict
import ST_DataModelBindings.bas.imp_stub as imp_dict
import ST_DataModelBindings.sys.dss_stub as dssDict
import ST_DataModelBindings.bas.ppr.par_stub as parDict
import ST_DataModelBindings.pro.ext_stub as extDict
import ST_DataModelBindings.bas.utd_stub as utdDict


"""
#unused imports and unused function 
import ST_DataModelBindings.dpd.ext.des_stub as desDpd
import ST_DataModelBindings.dpd.ext_stub as kidsDpd
import ST_DataModelBindings.dpd.mer_stub as merDpd
import ST_DataModelBindings.dpd.nir_stub as nirDpd
import ST_DataModelBindings.dpd.sim_stub as simDpd
import ST_DataModelBindings.dpd.sir_stub as sirDpd
import ST_DataModelBindings.dpd.vis_stub as visDpd

__processingFunctionDpds = {"DES": desDpd, "KID": kidsDpd, "KIDS": kidsDpd,
                            "MER": merDpd, "NIR": nirDpd, "SIM": simDpd,
                            "SIR": sirDpd, "VIS": visDpd}
#three quotation marks commented
dict: Python dictionary containing all the Processing function data
product bindings. 
#three quotation marks commented


def readProductMetadata(processingFunction, xmlFileName):
    #three quotation marks commented
    Reads an XML instance generated by a given processing function.

    Parameters
    ----------
    processingFunction: str
        The name of the processing function that defines the product instance.
        Possible values are: DES, KIDS, MER, NIR, SIM, SIR or VIS.
    xmlFileName: str
        The name of the XML file. It should include the full path.

    Returns
    -------
    object
        A python object containing the product metadata.

    #three quotation marks commented
    # Read the xml file as a string
    with open(xmlFileName, "r") as f:
        xmlString = f.read()

    # Create the product metadata using the correct data product dictionary
    dpdDict = __processingFunctionDpds[processingFunction]
    product = dpdDict.CreateFromDocument(xmlString)

    return product
"""

def saveProductMetadata(product, xmlFileName):
    """Saves an XML instance of a given data product.

    The XML instance will not be saved if the product does not validate the
    XML Schema.

    Parameters:
    -----------
    product: object
        The product metadata information that should be saved.
    xmlFileName: str
        The name of the XML file where the product metadata will be saved.

    """
    try:
        with open(xmlFileName, "w") as f:
            f.write(product.toDOM().toprettyxml(encoding="utf-8").decode("utf-8"))
    except pyxb.ValidationError as e:
        logging.error("The product does not validate the XML Schema definition and " +
              "it will not be saved.\n" + e.details())
        print(e.details())
    #


def validate(product):
    """Checks if the product metadata validates the XML Schema.

    Parameters:
    -----------
    product: object
        The product metadata information that should be validated.

    Returns
    -------
    str
        A string containing the result of the validation.

    """
    try:
        product.validateBinding()
        return "Valid binding"
    except pyxb.ValidationError as e:
        return "Invalid binding\n" + e.details()


def getFitsFileNames(product, fitsFormat=None):
    """Returns the FITS file names inside the product metadata.

    Parameters:
    -----------
    product: object
        The product metadata information.
    fitsFormat: str, optional
        The FITS file format to query for. Default is None.

    Returns:
    --------
    list
        The FITS file names.

    """
    # Transform the product to a DOM object
    productDom = product.toDOM()

    # Loop over all the DataContainer elements saving the file names
    fileNames = []

    for dataElement in productDom.getElementsByTagName("DataContainer"):
        if fitsFormat != None:
            # Check that it has the correct format
            formatId = dataElement.parentNode.getAttribute("format")

            if formatId != fitsFormat:
                continue

        # Append the file name to the list
        fileNameElement = dataElement.getElementsByTagName("FileName")[0]
        fileNames.append(fileNameElement.firstChild.nodeValue)

    return fileNames


def createBaseInstrument(telescope, instrument):
    """Creates a base instrument binding.

    Parameters:
    -----------
    telescope: str
        The telescope name
    instrument: str
        The instrument name

    Returns:
    --------
    object
        The base instrument binding.

    """
    # Create the base instrument binding
    baseInstrument = insDict.baseInstrument()

    # Fill it with the given values
    baseInstrument.InstrumentName = instrument
    baseInstrument.TelescopeName = telescope

    return baseInstrument


def createGroundInstrument(telescope, instrument):
    """Creates a ground instrument binding.

    Parameters:
    -----------
    telescope: str
        The telescope name
    instrument: str
        The instrument name

    Returns:
    --------
    object
        The ground instrument binding.

    """
    # Create the base instrument binding
    groundInstrument = insDict.groundInstrument()

    # Fill it with the given values
    groundInstrument.InstrumentName = instrument
    groundInstrument.TelescopeName = telescope
    groundInstrument.Latitude = -30.16606
    groundInstrument.Longitude = 70.81489
    groundInstrument.Elevation = 2215.0
    groundInstrument.Timezone = -4.0
    
    return groundInstrument


def createFilterList(filterNames):
    """Creates a filter list binding.

    Parameters:
    -----------
    filterNames: list
        A list of filter names.

    Returns:
    --------
    object
        The filter list binding.

    """
    # Create the filter list binding
    filterList = insDict.filterList()

    # Fill it with the given values
    for filterName in filterNames:
        filterList.append(filterName)

    return filterList


def createWCS(bindingClass, addNonLinearCoeffs=False):
    """Creates a WCS binding with default values.
    
    Parameters:
    -----------
    addNonLinearCoeffs: bool, optional
        If True, the WCS will contain the non-linear coefficients. Default is
        False.

    Returns:
    --------
    object
        The WCS binding.

    """
    # Create the wcs binding
    wcs = bindingClass.Factory()
    #cotDict.wcs()
                 
    # Fill it with default values                   
    pt = "TPV" if addNonLinearCoeffs else "TAN"
    wcs.CTYPE1 = pyxb.BIND(CoordinateType="RA", ProjectionType=pt)
    wcs.CTYPE2 = pyxb.BIND(CoordinateType="DEC", ProjectionType=pt)
#     wcs.CTYPE1 = imp_dict.projectionType()
#     wcs.CTYPE1.CoordinateType = "RA"
#     wcs.CTYPE1.ProjectionType = "TPV"
#     wcs.CTYPE2 = imp_dict.projectionType()
#     wcs.CTYPE2.CoordinateType = "RA"
#     wcs.CTYPE2.ProjectionType = "TPV"    
    wcs.CRVAL1 = 0.0
    wcs.CRVAL2 = 0.0
    wcs.CRPIX1 = 0.0
    wcs.CRPIX2 = 0.0
    wcs.CD1_1 = 1.0
    wcs.CD1_2 = 0.0
    wcs.CD2_1 = 0.0
    wcs.CD2_2 = 1.0

    # Add the non-linear PV coefficients if necessary
    if addNonLinearCoeffs:
        nonLinearCoeffs = cotDict.nonLinearAstromCoeffs()
        nonLinearTpvCoeffs = cotDict.nonLinearTPVAstromCoeffs()

        for attr in dir(nonLinearTpvCoeffs):
            if attr.startswith("PV"):
                setattr(nonLinearTpvCoeffs, attr, 0.0)

        wcs.NonLinearCoeffs = nonLinearCoeffs
        wcs.NonLinearCoeffs.NonLinearTPVAstromCoeffs = nonLinearTpvCoeffs

    return wcs


def createZeroPoint(value=1, error=0):
    """Creates a zero point binding.

    Parameters:
    -----------
    value: float, optional
        The zero point value. Default is 1.
    error: float, optional
        The zero point error. Default is 0.

    Returns:
    --------
    object
        The ZeroPoint binding.

    """
    # Create the zero point binding
    zp = cotDict.zeroPoint()

    # Fill it with the given values
    zp.unit = "mag"
    zp.Value = value
    zp.Error = error
    
    

    return zp


__masksDict = {"HotPixelMask":                 ["0x00000001", "1"],
               "ColdPixelMask":                ["0x00000002", "2"],
               "SaturatedPixelMask":           ["0x00000004", "4"],
               "CosmicRayPixelMask":           ["0x00000008", "8"],
               "SatelliteTrailPixelMask":      ["0x00000010", "16"],
               "InterpolatedPixelMask":        ["0x00000020", "32"],
               "BleedingPixelMask":            ["0x00000040", "64"],
               "OnBoardPixelMask":             ["0x00000080", "128"],
               "BadPixelMask":                 ["0x00000100", "256"],
               "NonLinearPixelMask":           ["0x00000200", "512"],
               "PersistentChargePixelMask":    ["0x00000400", "1024"],
               "GhostPixelMask":               ["0x00000800", "2048"],
               "TransientObjectPixelMas":      ["0x00001000", "4096"],
               "ExtendedObjectPixelMask":      ["0x00002000", "8192"],
               "ScatteredLightPixelMask":      ["0x00004000", "16384"],
               "ChargeInjectionPixelMask":     ["0x00008000", "32768"],
               "NearChargeInjectionPixelMask": ["0x00010000", "65536"]}
"""dict: Python dictionary containing the bit information of all the available
Euclid image bit masks."""


def createMaskList(maskNames):
    """Creates a bit mask list binding with the provided bit bitMaskList.

    Parameters:
    -----------
    maskNames: list
        List with the names of the bit bitMaskList that should be included.
        Use "all" to include all possible masks.

    Returns:
    --------
    object
        The bit mask list binding.

    """
    # Create the bit mask list binding
    bitMaskList = mskDict.bitMaskList()

    # Add all the requested masks
    if maskNames == None:
        pass
    elif "all" in maskNames:
        for mask in __masksDict:
            bits = __masksDict[mask]
            setattr(
                bitMaskList, mask, pyxb.BIND(hexBit=bits[0], decBit=bits[1]))
    else:
        for mask in maskNames:
            if mask in __masksDict:
                bits = __masksDict[mask]
                setattr(
                    bitMaskList, mask, pyxb.BIND(hexBit=bits[0], decBit=bits[1]))

    return bitMaskList


def createProcessingStep(name, programName, softwareVersion, parameters=None):
    """Creates a processing step binding.

    Parameters:
    -----------
    name: str
        The name of the processing step.
    programName: str
        The name of the program performing the processing step.
    softwareVersion: str
        The version of the program performing the processing step.
    parameters: dict, optional
        A dictionary with some specific parameters used in the processing step.
        Default is None.

    Returns:
    --------
    object
        The processing step binding.

    """
    # Create the processing step binding
    processingStep = pprDict.processingStep()

    # Fill it with the given values
    processingStep.Name = name
    processingStep.ProgramName = programName
    processingStep.SoftwareVersion = softwareVersion

    if parameters is not None:
        processingStep.ParametersList = pprDict.genericKeyValueParameters()

        for key in parameters:
            param = pprDict.genericKVParam()
            param.Key = key
            param.StringValue = str(parameters[key])
            processingStep.ParametersList.append(param)

    return processingStep


def createProcessingSteps(stepList):
    """Creates a processing step list binding.

    Parameters:
    -----------
    stepList: list
        List with the processing steps to add.

    Returns:
    --------
    object
        The processing step list binding.

    """
    # Create the processing step list binding
    processingSteps = pprDict.listOfProcessingSteps()

    # Add the processing steps
    if stepList is None:
        processingSteps.append(createProcessingStep("XXXX", "XXXX", "XXXX"))
    else:
        for step in stepList:
            processingSteps.append(step)

    return processingSteps


def createDataContainer(fileName, fileStatus="PROPOSED"):
    """Creates a data container binding.

    Parameters:
    -----------
    fileName: str
        The data file name.
    fileStatus: str, optional
        The status of the file: PROPOSED, PROCESSING, COMMITTED, VALIDATED,
        ARCHIVED or DELETED. Default is PROPOSED.

    Returns:
    --------
    object
        The data container binding.

    """
    # Create the data container binding
    dataContainer = dssDict.dataContainer()

    # Fill it with the given values
    dataContainer.FileName = fileName
    dataContainer.filestatus = fileStatus

    return dataContainer


def createFitsStorage(bindingClass, fileName, fileFormat, version = 0.2):
    """Creates a fits file storage binding.

    Parameters:
    -----------
    bindingClass: class
        The fits file binding class.
    fileName: str
        The fits file name.
    fileFormat: str
        The fits file format.
    version: str
        The fits file format version.

    Returns:
    --------
    object
        The fits file storage binding.

    """
    # Create the appropriate fits file storage binding
    storage = bindingClass.Factory()

    # Fill it with the given values
    storage.format = fileFormat
    storage.version = version
    storage.DataContainer = createDataContainer(fileName)

    return storage


def createCatalog(bindingClass, fileFormat):
    """Creates a catalog binding.

    Parameters:
    -----------
    bindingClass: class
        The catalog binding class.
    fileFormat: str
        The catalog fits file format.

    Returns:
    --------
    object
        The catalog binding.

    """
    # Create the catalog binding
    catalog = bindingClass.Factory()
    
    # Add the catalog id
    catalog.IdCatalog = 0   
    
    # Add the catalog storage
    catalog.CatalogStorage = catDict.catalogStorage()
    catalog.CatalogStorage.CatalogFileStorage = catDict.catalogFileStorage()
    catalog.CatalogStorage.CatalogFileStorage.FileNumber = 1
    catalog.CatalogStorage.CatalogFileStorage.FileFormat = catDict.catalogFileFormat("FITS") 
    catalog.CatalogStorage.CatalogFileStorage.Id = 'unknown' 
    
    catalog.CatalogCoverage = catDict.catalogCoverage()
    catalog.CatalogCoverage.SpatialCoverage = createSpatialFootprint()
    
    # Add the catalog description
    catalog.CatalogDescription = catDict.catalogDescription()
    description = catalog.CatalogDescription
    description.CatalogDataProduct = "XXXX"
    description.PathToCatalogDefinition = "XXXX"
    description.CatalogFormatBase = fileFormat
    description.CatalogFormatHDU = 0
    description.CatalogFitsColumnsDefinition = "XXXX"
    
    return catalog


def createSpatialFootprint():
    """Creates a spation footprint binding.
    
    Returns:
    --------
    object
        The spation footprint binding.
    
    """
    # Create the Scamp values binding
    spatialFootprint = cotDict.spatialFootprint()
    spatialFootprint.Polygon = stcDict.polygonType()
    
    # add 4 default values for the corners
    for i in [0,1,2,3]:
        vertex = stcDict.vertexType()
        vertex.Position = dtdDict.double2Type()
        vertex.Position.C1 = 0.0
        vertex.Position.C2 = 0.0
        spatialFootprint.Polygon.append(vertex)
    #
    
    return spatialFootprint


def createObservationDateTime(): 
    #ObservationDateTime
    observationDateTime = imgDict.groundObservationDateTime()
    observationDateTime.UTCObservationDateTime = datetime.now()
    observationDateTime.MjdObs = 0.0
    observationDateTime.Lst = 0.0
    observationDateTime.Utc = 0.0    
    return observationDateTime
#


def createImage(bindingClass):
    """Creates an image binding.

    Parameters:
    -----------
    bindingClass: class
        The image binding class.

    Returns:
    --------
    object
        The image binding.

    """
    # Create the appropriate image binding
    image = bindingClass.Factory()

    # Fill the image type metadata
    image.ImgType = esoDict.dataProduct()
    imgType = image.ImgType
    imgType.Category = "SCIENCE"
    imgType.FirstType = "STD"
    imgType.SecondType = "SKY"
    imgType.ThirdType = "WIDE"
    imgType.Technique = "IMAGE"

    # Fill the image properties metadata
    image.ImgNumber = "1"
    image.AxisNumber = "2"
    image.AxisLengths = "2048 4096"
    image.DataSize = "-32"
    image.DataLength = "8388608"

    return image


def createSingleImage(bindingClass, telescope, instrument, filterName):
    """Creates a single image binding.
    
    Parameters:
    -----------
    bindingClass: class
        The single image binding class.
    telescope: str
        The telescope name.
    instrument: str
        The instrument name.
    filterName: str
        The filter name.

    Returns:
    --------
    object
        The single image binding.

    """
    # Create the appropriate image binding
    image = createImage(bindingClass)
    
    # Add the instrument
    image.Instrument = createBaseInstrument(telescope, instrument)
    
    # Add the filter name
    image.Filter = insDict.baseFilter()
    image.Filter.Name = filterName
    
    # Add the WCS
    image.WCS = createWCS(cotDict.wcs, True)
    
    # Add the zero point
    image.ZeroPoint = createZeroPoint()
    
    #and the spatial footprint
    image.ImgSpatialFootprint = createSpatialFootprint()
    
    return image
#


def createGroundInstrumentImage(bindingClass, telescope, instrument, filterName):
    """Creates a detrended frame binding.
    
    Parameters:
    -----------
    bindingClass: class
        The detrended frame binding class.
    telescope: str
        The telescope name.
    instrument: str
        The instrument name.
    filterName: str
        The filter name.
        
    Returns:
    --------
    object
        The single image binding.
        
    """
    # Create the appropriate image binding
    image = createImage(bindingClass)
    image.Detector = "S12:R20"
    # Add the instrument
    image.Instrument = createGroundInstrument(telescope, instrument)
    
    # Add the filter name
    image.Filter = insDict.baseFilter()
    image.Filter.Name = filterName
    
    # Add the WCS
    image.WCS = createWCS(cotDict.wcs, True)
    
    image.Zeropoint = createZeroPoint()

    #and the spatial footprint
    image.ImgSpatialFootprint = createSpatialFootprint()
    
    #ObservationDateTime
    image.ObservationDateTime = createObservationDateTime()
    
    return image
    
#


def createExtPsf(bindingClass, telescope, instrument, filterName):
    """Creates a ext psf binding.
    
    Parameters:
    -----------
    bindingClass: class
        The detrended frame binding class.
    telescope: str
        The telescope name.                                                                                                                    
    instrument: str
        The instrument name.
    filterName: str
        The filter name.
        
    Returns:
    --------
    object
        The single image binding.
        
    """
    # Create the appropriate image binding
    image = createImage(bindingClass)
    
    # Add the instrument
    image.Instrument = createGroundInstrument(telescope, instrument)
    
    #QualityParams
    image.QualityParams = extDict.extPsfModelDqp()
    
    #ObservationDateTime
    image.ObservationDateTime = createObservationDateTime()
    
    #Detector
    image.Detector = "DECam"
    
    # Add the filter name
    image.Filter = insDict.baseFilter()
    image.Filter.Name = filterName
    
    
    return image
    
#


def createExtAstromSolution(bindingClass, telescope, instrument, filterName):
    """Creates a detrended frame binding.
    
    Parameters:
    -----------
    bindingClass: class
        The detrended frame binding class.
    telescope: str
        The telescope name.
    instrument: str
        The instrument name.
    filterName: str
        The filter name.
        
    Returns:
    --------
    object
        The single image binding.
        
    """
    # Create the appropriate image binding
    #image = bindingClass.Factory()
    image = createWCS(bindingClass, True)
    
    # Add the instrument
    image.Instrument = createGroundInstrument(telescope, instrument)
                             
    # Add the filter name
    image.Filter = insDict.baseFilter()
    image.Filter.Name = filterName
    
    #ProcessParams
    image.ProcessParams = parDict.extAstromSolutionParameters()
    
    #QualityParams
    image.QualityParams = extDict.extAstromSolutionDqp()
    
    #ObservationDateTime
    image.ObservationDateTime = createObservationDateTime()
    
    #Detector
    image.Detector = "DECam"
    
    return image
#


def createExtPhotomSolution(bindingClass, telescope, instrument, filterName):
    """Creates a detrended frame binding.
    
    Parameters:
    -----------
    bindingClass: class
        The detrended frame binding class.
    telescope: str
        The telescope name.
    instrument: str
        The instrument name.
    filterName: str
        The filter name.
        
    Returns:
    --------
    object
        The single image binding.
        
    """
    image = bindingClass.Factory()
    image.unit = "mag"
    image.Value = 0.0
    image.Error = 0.0
    image.ZeroPointType = 'relative'
    
    # Add the instrument
    image.Instrument = createGroundInstrument(telescope, instrument)
                             
    # Add the filter name
    image.Filter = insDict.baseFilter()
    image.Filter.Name = filterName
    
    #ProcessParams
    image.ProcessParams = parDict.extPhotomSolutionParameters()
    
    #QualityParams
    image.QualityParams = extDict.extPhotomSolutionDqp()
    
    #ObservationDateTime
    image.ObservationDateTime = createObservationDateTime()
    
    #Detector
    image.Detector = "DECam"
    
    return image
#



def createExtSourceCatalog(bindingClass, telescope, instrument, filterName):
    """Creates a detrended frame binding.
    
    Parameters:
    -----------
    bindingClass: class
        The detrended frame binding class.
    telescope: str
        The telescope name.
    instrument: str
        The instrument name.
    filterName: str
        The filter name.
        
    Returns:
    --------
    object
        The source catalog binding.
        
    """
    image = bindingClass.Factory()
    
    # Add the instrument
    image.Instrument = createGroundInstrument(telescope, instrument)
                             
    # Add the filter name
    image.Filter = insDict.baseFilter()
    image.Filter.Name = filterName
    
    #ProcessParams
    image.ProcessParams = parDict.extSourceCatalogParameters()
    
    #QualityParams
    image.QualityParams = extDict.extSourceCatalogDqp()
    
    #ObservationDateTime
    image.ObservationDateTime = createObservationDateTime()
    
    
    #Detector
    image.Detector = "DECam"
    
    return image
#


def createStackedImage(bindingClass, telescope, instrument, filterName):
    """Creates a stacked image binding.

    Parameters:
    -----------
    bindingClass: class
        The stacked image binding class.
    telescope: str
        The telescope name.
    instrument: str
        The instrument name.
    filterName: str
        The filter name.

    Returns:
    --------
    object
        The stacked image binding.

    """
    # Create the appropriate image binding
    image = createImage(bindingClass)

    # Add the instrument
    image.Instrument = createBaseInstrument(telescope, instrument)

    # Add the filter name
    image.Filter = insDict.baseFilter()
    image.Filter.Name = filterName
    

    # Add the WCS
    image.WCS = createWCS(cotDict.wcs, False)

    # Add the zero point
    image.ZeroPoint = createZeroPoint()

    return image


def addExtraFunctionality(dpdBindingClass):
    """Adds some extra functionality to a data product binding class.

    Parameters:
    -----------
    dpdBindingClass: class
        The data product binding class.

    """
    # Check that it contains a Data attribute
    if not hasattr(dpdBindingClass, "Data"):
        logging.error("The provided binding should contain a Data element.\n" +
              "No extra functionality added.")
        return

    # Create a temporal binding instance
    dpdInstance = dpdBindingClass.Factory()

    # Create the Data element
    dpdInstance.Data = pyxb.BIND()
    dataElement = dpdInstance.Data

    # Add the methods to the data product class
    if hasattr(dataElement, "ZeroPoint"):
        dpdBindingClass.setZeroPoint = __setZeroPoint
    if hasattr(dataElement, "Masks"):
        dpdBindingClass.setMasks = __setMasks
    if hasattr(dataElement, "ProcessingSteps"):
        dpdBindingClass.setProcessingSteps = __setProcessingSteps
        dpdBindingClass.addProcessingStep = __addProcessingStep


def __setZeroPoint(self, value, error):
    """Sets the zero point.

    Parameters:
    -----------
    value: float
        The zero point value.
    error: float
        The zero point error.

    """
    self.Data.ZeroPoint = createZeroPoint(value, error)


def __setMasks(self, maskNames):
    """Sets the image bit masks.

    Parameters:
    -----------
    maskNames: list
        List with the names of the bit bitMaskList that should be included.
        Use "all" to include all possible masks.

    """
    self.Data.Masks = createMaskList(maskNames)


def __setProcessingSteps(self, stepList):
    """Sets the processing steps.

    Parameters:
    -----------
    stepList: list
        List with the processing steps to add.

    """
    self.Data.ProcessingSteps = createProcessingSteps(stepList)


def __addProcessingStep(self, step):
    """Adds a processing step to the list of processing steps.

    Parameters:
    -----------
    step: object
        The processing step that should be added.

    """
    if self.Data.ProcessingSteps is None:
        self.Data.ProcessingSteps = createProcessingSteps([step])
    else:
        self.Data.ProcessingSteps.append(step)